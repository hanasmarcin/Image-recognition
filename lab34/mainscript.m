% mainscript is rather short this time% primary component countcomp_count = 40; [tvec tlab tstv tstl] = readSets(); % let's look at the first digit in the training setimshow(1-reshape(tvec(1,:), 28, 28)');% let's check labels in both sets[unique(tlab)'; unique(tstl)'];% compute and perform PCA transformation[mu trmx] = prepTransform(tvec, comp_count);tvec = pcaTransform(tvec, mu, trmx);tstv = pcaTransform(tstv, mu, trmx);% let's shift labels by one to use labels directly as indicestlab = tlab + 1;tstl = tstl + 1;% To successfully prepare ensemble you have to implement perceptron function% I would use 10 first zeros and 10 fisrt ones % and only 2 first primary components% It'll allow printing of intermediate results in perceptron function%% YOUR CODE GOES HERE - testing of the perceptron function% Przygotowanie danychzero_class = tvec(tlab == 1, :);one_class = tvec(tlab == 2, :);zero_class = zero_class(1:100, 1:2);one_class = one_class(1:100, 1:2);[sepplane fp fn] = perceptron(zero_class, one_class)plot(zero_class(:, 1), zero_class(:, 2), 'r.', 'MarkerSize', 4);hold on;plot(one_class(:, 1), one_class(:, 2), 'b.', 'MarkerSize', 4);x = min([zero_class(:, 1);one_class(:, 1)]):0.1:max([zero_class(:, 1);one_class(:, 1)]);y = -sepplane(1)/sepplane(3) -sepplane(2)/sepplane(3)*x;plot(x, y, 'g')legend(["Klasa 1.", "Klasa 2.", "P³. decyzyjna"], 'Location', 'northeastoutside');xlabel('Cecha 1.');ylabel('Cecha 2.');ylim([min([zero_class(:, 2);one_class(:, 2)]), max([zero_class(:, 2);one_class(:, 2)])]);title('Rozk³ad klas w przestrzeni dwóch cech');% OVO% training of the whole ensemble[ovo, errors] = trainOVOensamble(tvec, tlab, @perceptron);% check your ensemble on train setclab = unamvoting(tvec, ovo);cfmx = confMx(tlab, clab);errors_for_classes = (diag(cfmx)./sum(cfmx, 2))';errors_summary = compErrors(cfmx)% repeat on test setclab = unamvoting(tstv, ovo);cfmx = confMx(tstl, clab);errors_for_classes = (diag(cfmx)./sum(cfmx, 2))';errors_summary = compErrors(cfmx);% OVR% training of the whole ensemble[ovr, errors] = trainOVRensamble(tvec, tlab, @perceptron);% check your ensemble on train setclab_ovr = unamvotingOVR(tvec, ovr);cfmx_ovr = confMx(tlab, clab_ovr);errors_for_classes = (diag(cfmx_ovr)./sum(cfmx_ovr, 2))';errors_summary = compErrors(cfmx_ovr)% repeat on test setclab_ovr = unamvotingOVR(tstv, ovr);cfmx_ovr = confMx(tstl, clab_ovr);errors_for_classes = (diag(cfmx_ovr)./sum(cfmx_ovr, 2))';errors_summary = compErrors(cfmx_ovr)% Zwiekszenie liczby cech tvec = expandFeatures(tvec);tstv = expandFeatures(tstv);% OVO% training of the whole ensemble[ovo, errors] = trainOVOensamble(tvec, tlab, @perceptron);% check your ensemble on train setclab = unamvoting(tvec, ovo);cfmx = confMx(tlab, clab);errors_for_classes = (diag(cfmx)./sum(cfmx, 2))';errors_summary = compErrors(cfmx)% repeat on test setclab = unamvoting(tstv, ovo);cfmx = confMx(tstl, clab);errors_for_classes = (diag(cfmx)./sum(cfmx, 2))';errors_summary = compErrors(cfmx);% OVR% training of the whole ensemble[ovr, errors] = trainOVRensamble(tvec, tlab, @perceptron);% check your ensemble on train setclab_ovr = unamvotingOVR(tvec, ovr);cfmx_ovr = confMx(tlab, clab_ovr);errors_for_classes = (diag(cfmx_ovr)./sum(cfmx_ovr, 2))';errors_summary = compErrors(cfmx_ovr)% repeat on test setclab_ovr = unamvotingOVR(tstv, ovr);cfmx_ovr = confMx(tstl, clab_ovr);errors_for_classes = (diag(cfmx_ovr)./sum(cfmx_ovr, 2))';errors_summary = compErrors(cfmx_ovr)